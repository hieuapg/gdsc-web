
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>USF GDSC Fall 2024 Web Development Workshop</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="docs"
                  title="USF GDSC Fall 2024 Web Development Workshop"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Introduction" duration="0">
        <p>We're gonna make AI Chatbot with Gemini API and HTML/CSS/JS !</p>
      </google-codelab-step>
    
      <google-codelab-step label="Setup screen" duration="0">
        <h2>setup HTML file</h2>
<p>index.html</p>
<pre><code language="language-html" class="language-html">
    &lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title>Gemini Chatbot&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    
&lt;/body&gt;
&lt;/html&gt; 
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Make HTML body" duration="0">
        <p>index.html:</p>
        <ol>
          <li>add main components into to build up the page structure (2 sections: input-button + response field)</li>
          <li>assign ids to the elements</li>
        </ol>
<pre><code language="language-html" class="language-html">
&lt;header&gt;
    &lt;h1&gt;Generative AI Chat&lt;/h1&gt;
&lt;/header&gt;
&lt;main&gt;
    &lt;section&gt;
        &lt;h2&gt;Ask a Question&lt;/h2&gt;
        &lt;form&gt;
            &lt;input type=&quot;text&quot; id=&quot;query&quot; placeholder=&quot;Type your question&quot;&gt;
            &lt;button type=&quot;button&quot; id=&quot;myButton&quot;&gt;Ask&lt;/button&gt;
        &lt;/form&gt;
    &lt;/section&gt;
    &lt;section&gt;
        &lt;h2&gt;Response&lt;/h2&gt;
        &lt;div id=&quot;response-container&quot;&gt;
            &lt;!-- Response will be displayed here --&gt;
        &lt;/div&gt;
    &lt;/section&gt;
&lt;/main&gt;
</code></pre>
<p>style.css:</p>
<ol>
  <li>create and link CSS file to HTML main page</li>
  <li>edit CSS to format the styles of HTML elements</li>
</ol>
<pre><code language="language-css" class="language-css">
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
}

header {
    background: #333;
    color: #fff;
    padding: 1em;
    text-align: center;
}

main {
    padding: 1em;
}

form {
    margin-bottom: 1em;
}

input {
    padding: 0.5em;
    font-size: 1em;
}

button {
    padding: 0.5em;
    font-size: 1em;
    background: #007bff;
    color: #fff;
    border: none;
    cursor: pointer;
}

button:hover {
    background: #0056b3;
}

#response-container {
    border: 1px solid #ddd;
    padding: 1em;
    background: #f9f9f9;
}
</code></pre>



      </google-codelab-step>
    
      <google-codelab-step label="Setup Gemini API" duration="0">
        <h2>Install and import Gemini API</h2>
        <ol>
          <li>Google AI for Developers (https://ai.google.dev/)</li>
          <li>Navigate to Docs -> Quickstart -> Web(SDK)</li>
          <li>Install Gemini API to HTML by CDN link</li>
<pre><code language="language-html" class="language-html">
&lt;script type=&quot;importmap&quot;&gt;
  {
    &quot;imports&quot;: {
      &quot;@google/generative-ai&quot;: &quot;https://esm.run/@google/generative-ai&quot;
    }
  }
&lt;/script&gt;
</code></pre>

<li>Import Gemini API library</li>
        </ol>
<pre><code language="language-html" class="language-html">
&lt;script type="module"&gt;
    import { GoogleGenerativeAI } from "@google/generative-ai";

    // Fetch your API_KEY
    const API_KEY = "...";
&lt;/script&gt;
</code></pre>

        <h2>Retrieve API Key</h2>
        <ol>
          <li>Navigate to Google AI Studio -> Get API Key</li>
          <li>Select "Generative Language Client" -> Create Key</li>
          <li>Copy Key to API_KEY (keep API_KEY secret!)</li>
        </ol>


      </google-codelab-step>
    
      <google-codelab-step label="Setup structure to make the requests" duration="0">
        <p>index.html:</p>
        <ol>
          <li>setup async function generate() for requests</li>
          <li>add event listener for request command</li>
        </ol>
        <pre><code class="language-html" language="language-html">
&lt;script type="module"&gt;
    document.getElementById('myButton').addEventListener('click', generate); // Event listener
    import { GoogleGenerativeAI } from "@google/generative-ai";

    const API_KEY = "...";
    const genAI = new GoogleGenerativeAI(API_KEY);

    async function generate() { &lt;!-- requests function --&gt;
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    
        const prompt = "Write a story about a magic backpack.";
    
        const result = await model.generateContent(prompt);
        const response = await result.response;
        let text = response.text(); 
    
        console.log(text);
    }
&lt;/script&gt;
</code></pre>

<p>Test the function, it should display on the console if correct</p>

      </google-codelab-step>
    
      <google-codelab-step label="Get users' prompts and display results" duration="0">
        <p>index.html:</p>
        <ol>
          <li>modify prompt to value of id 'query'</li>
          <li>add text to id 'response-container</li>
        </ol>
<pre><code class="language-html" language="language-html">
&lt;script type="module"&gt;
    document.getElementById('myButton').addEventListener('click', generate); // Event listener
    import { GoogleGenerativeAI } from "@google/generative-ai";

    const API_KEY = "...";
    const genAI = new GoogleGenerativeAI(API_KEY);

    async function generate() { &lt;!-- requests function --&gt;
        const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    
        const prompt = document.getElementById('query').value; // Take users' inputs as prompt
    
        const result = await model.generateContent(prompt);
        const response = await result.response;
        let text = response.text();

        document.getElementById('response-container').innerHTML = text; // Add response to page
        console.log(text);
    }
&lt;/script&gt;
</code></pre>

<p>Test the functions. It should answers users' questions and display it on the screen</p>

      </google-codelab-step>
    
      <google-codelab-step label="Add formatting to answer" duration="0">
<pre><code language="language-javascript" class="language-javascript">
    text = text
            .replace(/##\s*(.*?)\s*\n/g, "&lt;h2&gt;$1&lt;/h2&gt;&lt;br&gt;")
            .replace(/\*\*(.*?)\*\*/g, "&lt;strong&gt;$1&lt;/strong&gt;")
            .replace(/\n/g, "&lt;br&gt;");

</code></pre>
<p>Script:</p>
<pre><code language="language-html" class="language-html"><pre><code class="language-html" language="language-html">
&lt;script type="module"&gt;
    document.getElementById('myButton').addEventListener('click', generate);
    import { GoogleGenerativeAI } from "@google/generative-ai";
    const API_KEY = "...";
    const genAI = new GoogleGenerativeAI("API_KEY");

    async function generate() {
        const model = genAI.getGenerativeModel({ model: "gemini-pro" });

        const prompt = document.getElementById('query').value;

        const result = await model.generateContent(prompt);
        const response = await result.response;
        let text = response.text(); 

        // Replace for proper display
        text = text
            .replace(/##\s*(.*?)\s*\n/g, "&lt;h2&gt;$1&lt;/h2&gt;&lt;br&gt;")
            .replace(/\*\*(.*?)\*\*/g, "&lt;strong&gt;$1&lt;/strong&gt;")
            .replace(/\n/g, "&lt;br&gt;");

        document.getElementById('response-container').innerHTML = text;
        console.log(text);
    }
&lt;/script&gt;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Check for collisionos with wall" duration="0">
        <p>snake.py: - Complete check collission with wall method in Snake class -  Complete detect collission with self method in Snake class</p>
<pre><code language="language-python" class="language-python">class Snake:
    def __init__(self) -&gt; None:
        self.head = Head((0,0)) 
        self.segments = [self.head, Segment((-20, 0)), Segment((-40, 0))] 
        self.previous_tail_coord = (-40, 0)
        
    def move_forward(self):
        self.previous_tail_coord = self.segments[-1].get_position()
        for i in range (len(self.segments) - 1, 0, -1):
            self.segments[i].change_position(self.segments[i - 1].get_position())
        self.head.move_forward()
        
    def turn_left(self):
        self.head.turn_left()
        
    def turn_right(self):
        self.head.turn_right()
        
    def turn_up(self):
        self.head.turn_up()
        
    def turn_down(self):
        self.head.turn_down()
    
    def eat_food(self):
        self.segments.append(Segment(initial_position=self.previous_tail_coord))
        
    def detect_collision_food(self, food) -&gt; bool:
        if self.head.get_distance(food) &lt;= 15:
            self.eat_food()
            return True
        return False
    
    def detect_collision_wall(self) -&gt; bool:
        headpos = self.head.get_position()
        return headpos[0] &gt; 290 or headpos[0] &lt; -290 or headpos[1] &gt; 290 or headpos[1] &lt; -290 #check if x-y coord inside screen
    
    def detect_collision_self(self) -&gt; bool:
      for i in range (1, len(self.segments)): # check if head collide with any segments
          if self.head.get_distance(self.segments[i].get_position()) &lt;= 10:
              return True
      return False
</code></pre>
<p>main.py : - add conditional statement to game over method for collission with wall if so change game state attribute - call game over method at the end of the game loop - add detect collission with self to the conditionoal statement in game over method</p>
<pre><code language="language-python" class="language-python">from time import sleep
from turtle import Screen
from snake import Snake
from food import Food

class GameController:
    def __init__(self) -&gt; None:
        self.game_ended = False
        self.screen = Screen()
        self.screen.setup(width=600, height=600)
        self.screen.bgcolor(&#39;black&#39;)
        self.screen.tracer(0)
        
        self.snake = Snake()
        self.food = Food()
        
        self.screen.listen()
        self.screen.onkeypress(self.snake.turn_left, &#34;Left&#34;)
        self.screen.onkeypress(self.snake.turn_right, &#34;Right&#34;)
        self.screen.onkeypress(self.snake.turn_up, &#34;Up&#34;)
        self.screen.onkeypress(self.snake.turn_down, &#34;Down&#34;)
        self.game_loop()
        self.screen.exitonclick()
        self.screen.mainloop() 
        
    def detect_collision_food(self):
        if self.snake.detect_collision_food(self.food):
            self.food.move_around()
    
    def game_over_condition(self):
        if self.snake.detect_collision_self() or self.snake.detect_collision_wall():
            self.game_ended = True
    
    def game_loop(self):
        while not self.game_ended:
            self.snake.move_forward()
            sleep(0.1)
            self.screen.update()
            self.detect_collision_food()
            self.game_over_condition()

game = GameController()
</code></pre>
<p>Create Scoreboard</p>
<p>scoreboard.py; - add basic visual setup and score attribute to Scoreboard class - complete write_score method (which should clear itself before writing score) - call write score method in init method</p>
<pre><code language="language-python" class="language-python">from turtle import Turtle 

class Scoreboard(Turtle):

    def __init__(self, shape: str = &#34;classic&#34;, undobuffersize: int = 1000, visible: bool = True) -&gt; None:
        super().__init__(shape, undobuffersize, visible)

        self.score = 0 
        self.color(&#39;white&#39;) 
        self.penup() 
        self.hideturtle() 
        self.goto(0,265) 
        self.write_score() 

    # method to write score
    def write_score(self):
        self.clear()
        self.write(f&#39;Score: {self.score}&#39;, align=&#39;center&#39;, font=(&#39;Verdana&#39;, 25, &#39;normal&#39;)) 

    # increase the score by one and write the new score
    def increment_score(self):
        self.score += 1
        self.write_score()


</code></pre>
<p>main.py: - cerate an instance of scoreboaord inside the Gamecontroller class init method</p>
<pre><code language="language-python" class="language-python">from time import sleep
from turtle import Screen
from scoreboard import Scoreboard
from snake import Snake
from food import Food

class GameController:
    def __init__(self) -&gt; None:
        self.game_ended = False
        self.screen = Screen()
        self.screen.setup(width=600, height=600)
        self.screen.bgcolor(&#39;black&#39;)
        self.screen.tracer(0)

        self.scoreboard = Scoreboard()
        self.snake = Snake()
        self.food = Food()
        
        self.screen.listen()
        self.screen.onkeypress(self.snake.turn_left, &#34;Left&#34;)
        self.screen.onkeypress(self.snake.turn_right, &#34;Right&#34;)
        self.screen.onkeypress(self.snake.turn_up, &#34;Up&#34;)
        self.screen.onkeypress(self.snake.turn_down, &#34;Down&#34;)
        self.game_loop()
        self.screen.exitonclick()
        self.screen.mainloop() 
        
    def detect_collision_food(self):
        if self.snake.detect_collision_food(self.food):
            self.food.move_around()
            self.scoreboard.increment_score() #increase score when eat food
    
    def game_over_condition(self):
        if self.snake.detect_collision_self() or self.snake.detect_collision_wall():
            self.game_ended = True
            
    
    def game_loop(self):
        while not self.game_ended:
            self.snake.move_forward()
            sleep(0.1)
            self.screen.update()
            self.detect_collision_food()
            self.game_over_condition()

game = GameController()
</code></pre>
<p>Game Over screen</p>
<p>scoreboard.py: - Complete write_game_over method</p>
<pre><code language="language-python" class="language-python">from turtle import Turtle 

class Scoreboard(Turtle):

    def __init__(self, shape: str = &#34;classic&#34;, undobuffersize: int = 1000, visible: bool = True) -&gt; None:
        super().__init__(shape, undobuffersize, visible)

        self.score = 0 
        self.color(&#39;white&#39;) 
        self.penup() 
        self.hideturtle() 
        self.goto(0,265) 
        self.write_score() 

    # method to write score
    def write_score(self):
        self.clear()
        self.write(f&#39;Score: {self.score}&#39;, align=&#39;center&#39;, font=(&#39;Verdana&#39;, 25, &#39;normal&#39;)) 

    # increase the score by one and write the new score
    def increment_score(self):
        self.score += 1
        self.write_score()

    # game over screen
    def write_game_over(self):
        self.goto(0,0)
        self.color(&#34;red&#34;)
        self.write(&#34;Game Over&#34;, align=&#34;center&#34;, font=(&#34;Verdana&#34;, 69, &#34;normal&#34;))
        self.color(&#34;white&#34;)
        self.goto(0,-30)
        self.write(&#34;Press Space to Continue&#34;, align=&#34;Center&#34;, font=(&#34;Verdana&#34;, 18, &#34;normal&#34;))
        self.goto(0,265)
 

</code></pre>
<p>main.py; - if conditional statement in game over is true call the scoreboard&#39;s write game over method</p>
<pre><code language="language-python" class="language-python">from turtle import Screen
from scoreboard import Scoreboard
from food import Food
from snake import Snake
from time import sleep

class GameController:
    
    def __init__(self) -&gt; None:

        self.game_ended = False

        # Setup Screen
        self.screen = Screen()
        self.screen.setup(width=600, height=600)
        self.screen.bgcolor(&#39;black&#39;)
        self.screen.tracer(0)
        

        # Initialize instance of game objects
        self.scoreboard = Scoreboard()
        self.snake = Snake()
        self.food = Food()
        
        # add screen listeners
        self.screen.listen()
        self.screen.onkeypress(self.snake.turn_left, &#39;Left&#39;)
        self.screen.onkeypress(self.snake.turn_right, &#39;Right&#39;)

        # start main loop
        self.game_loop()

        self.screen.exitonclick()

    # check whether snake head has touched food, if so eat it and move food
    def detect_collision_food(self):
        if self.snake.detect_collission_food(self.food):
            self.food.move_around()
            self.scoreboard.increment_score()

    # check for game over conditions and display game over screen
    def game_over(self):
        if self.snake.detect_collission_wall() or self.snake.detect_collission_self():
            self.game_ended = True
            self.scoreboard.write_game_over() 

 
    # main game looop, make snake go forward, update screen and check for collisioons with good and game over
    def game_loop(self):
        while not self.game_ended:
            self.snake.move_forward()
            sleep(0.1)
            self.screen.update()
            self.detect_collision_food()
            self.game_over()

GameController()
</code></pre>
<p>Reset functionality</p>
<p>snake.py: - Complete the reset method in the snake class</p>
<pre><code language="language-python" class="language-python">from turtle import Turtle 

# a unit of the snake
class Segment:
    def __init__(self, initial_position) -&gt; None:
        self.position = initial_position
        self.turtle = Turtle(shape=&#39;square&#39;)
        self.turtle.color(&#39;white&#39;)
        self.turtle.penup()
        self.turtle.goto(initial_position)

    # return position 
    def get_position(self):
        return self.position

    # move segment to coordinate
    def change_position(self, new_position):
        self.turtle.goto(new_position)
        self.position = new_position

# unit of snake that represents head
class Head(Segment):
    def __init__(self, initial_position) -&gt; None:
        super().__init__(initial_position)

    # advance
    def move_forward(self):
        self.turtle.forward(20)
        self.position = self.turtle.pos()

    # change directioon left
    def turn_left(self):
        self.turtle.left(90)
    
    # change direction right
    def turn_right(self):
        self.turtle.right(90)

    # check how far an object is
    def get_distance(self, coord):
        return self.turtle.distance(coord)

    # check if crashed with wall
    def collision_wall(self):
        return self.position[0] &gt; 290 or self.position[0] &lt; -290 or self.position[1] &gt; 290 or self.position[1] &lt; -290

class Snake:
    def __init__(self) -&gt; None:
        self.head = Head((0,0))
        self.segments = [self.head, Segment((-20, 0)), Segment((-40, 0))]
        self.previous_tail_coord = (-40, 0)

    # move entire snake forward
    def move_forward(self): 
        self.previous_tail_coord = self.segments[-1].get_position()
        for i in range(len(self.segments) - 1, 0, -1): 
            self.segments[i].change_position(self.segments[i - 1].get_position()) 
        self.head.move_forward()

    # change directiions left
    def turn_left(self):
        self.head.turn_left()

    # change directions right 
    def turn_right(self):
        self.head.turn_right()

    # make snake bodoy larger when a food is eaten
    def eat_food(self):
        self.segments.append(Segment(self.previous_tail_coord))

    # check whether snake head touched food
    def detect_collission_food(self, food):
        if self.head.get_distance(food) &lt;= 15:
            self.eat_food()
            return True
        return False
    
    # check whether snake head touched the body
    def detect_collission_self(self):
        for x in range(1, len(self.segments)):
            if self.head.get_distance(self.segments[x].get_position()) &lt;= 10:
                return True
        return False

    # check whether snake touched screem edges
    def detect_collission_wall(self):
        return self.head.collision_wall()
    
    # make snake revert to initial size and position
    def reset(self): 
        for seg in self.segments: 
            seg.turtle.goto(100000,100000) 
        self.segments.clear() 
        self.head = Head((0,0)) 
        self.segments = [self.head, Segment((-20,0)), Segment((-40,0))]
        self.previous_tail_coord = (-40,0) 
</code></pre>
<p>scoreboard.py: - Complete reset method in scoreboard class</p>
<pre><code language="language-python" class="language-python">from turtle import Turtle 

class Scoreboard(Turtle):

    def __init__(self, shape: str = &#34;classic&#34;, undobuffersize: int = 1000, visible: bool = True) -&gt; None:
        super().__init__(shape, undobuffersize, visible)

        self.score = 0 
        self.color(&#39;white&#39;) 
        self.penup() 
        self.hideturtle() 
        self.goto(0,265) 
        self.write_score() 

    # method to write score
    def write_score(self):
        self.clear()
        self.write(f&#39;Score: {self.score}&#39;, align=&#39;center&#39;, font=(&#39;Verdana&#39;, 25, &#39;normal&#39;)) 

    # increase the score by one and write the new score
    def increment_score(self):
        self.score += 1
        self.write_score()

    # game over screen
    def write_game_over(self):
        self.goto(0,0)
        self.color(&#34;red&#34;)
        self.write(&#34;Game Over&#34;, align=&#34;center&#34;, font=(&#34;Verdana&#34;, 69, &#34;normal&#34;))
        self.color(&#34;white&#34;)
        self.goto(0,-30)
        self.write(&#34;Press Space to Continue&#34;, align=&#34;Center&#34;, font=(&#34;Verdana&#34;, 18, &#34;normal&#34;))
        self.goto(0,265)
 
    # revert to initial scoreboard 
    def reset(self):
        self.score = 0 
        self.write_score() 
</code></pre>
<p>main.py: - Complete reset method in Game Controller class - Add a keypress listener to game over mehtod (if game has ended) that calls reset method when activated</p>
<pre><code language="language-python" class="language-python">from turtle import Screen
from scoreboard import Scoreboard
from food import Food
from snake import Snake
from time import sleep

class GameController:
    
    def __init__(self) -&gt; None:

        self.game_ended = False

        # Setup Screen
        self.screen = Screen()
        self.screen.setup(width=600, height=600)
        self.screen.bgcolor(&#39;black&#39;)
        self.screen.tracer(0)
        

        # Initialize instance of game objects
        self.scoreboard = Scoreboard()
        self.snake = Snake()
        self.food = Food()
        
        # add screen listeners
        self.screen.listen()
        self.screen.onkeypress(self.snake.turn_left, &#39;Left&#39;)
        self.screen.onkeypress(self.snake.turn_right, &#39;Right&#39;)

        # start main loop
        self.game_loop()

        self.screen.exitonclick()

    # check whether snake head has touched food, if so eat it and move food
    def detect_collision_food(self):
        if self.snake.detect_collission_food(self.food):
            self.food.move_around()
            self.scoreboard.increment_score()

    # check for game over conditions and display game over screen
    def game_over(self):
        if self.snake.detect_collission_wall() or self.snake.detect_collission_self():
            self.game_ended = True
            self.screen.onkey(fun=self.reset_game, key=&#34;space&#34;) 
            self.scoreboard.write_game_over() 

    # reset the game
    def reset_game(self): 
            self.scoreboard.reset() 
            self.snake.reset() 
            # self.screen.onkey(fun=None, key=&#34;space&#34;) 
            self.game_ended = False 
            self.game_loop()

    # main game looop, make snake go forward, update screen and check for collisioons with good and game over
    def game_loop(self):
        while not self.game_ended:
            self.snake.move_forward()
            sleep(0.1)
            self.screen.update()
            self.detect_collision_food()
            self.game_over()

GameController()

</code></pre>
<p>Good job!!!.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
